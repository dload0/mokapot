//! JVM methods.

use std::fmt::Display;

use bitflags::bitflags;

use crate::types::{
    method_descriptor::{MethodDescriptor, ReturnType},
    signitures::MethodSignature,
};

use super::{
    annotation::{Annotation, ElementValue, TypeAnnotation},
    class::ClassReference,
    code::MethodBody,
};

/// A JVM method.
/// See the [JVM Specification ยง4.6](https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.6) for more information.
#[derive(Debug, Clone)]
pub struct Method {
    /// The access flags of the method.
    pub access_flags: MethodAccessFlags,
    /// The name of the method.
    pub name: String,
    /// The descriptor of the method.
    pub descriptor: MethodDescriptor,
    /// The class containing the method.
    pub owner: ClassReference,
    /// The body of the method if it is not `abstract`` or `native`.
    pub body: Option<MethodBody>,
    /// The checked exceptions that may be thrown by the method.
    pub exceptions: Vec<ClassReference>,
    /// The runtime visible annotations.
    pub runtime_visible_annotations: Vec<Annotation>,
    /// The runtime invisible annotations.
    pub runtime_invisible_annotations: Vec<Annotation>,
    /// The runtime visible type annotations.
    pub runtime_visible_type_annotations: Vec<TypeAnnotation>,
    /// The runtime invisible type annotations.
    pub runtime_invisible_type_annotations: Vec<TypeAnnotation>,
    /// The runtime visible parameter annotations.
    pub runtime_visible_parameter_annotations: Vec<Vec<Annotation>>,
    /// The runtime invisible parameter annotations.
    pub runtime_invisible_parameter_annotations: Vec<Vec<Annotation>>,
    /// The default value of the annotation.
    pub annotation_default: Option<ElementValue>,
    /// The parameters of the method.
    pub parameters: Vec<ParameterInfo>,
    /// Indicates if the method is synthesized by the compiler.
    pub is_synthetic: bool,
    /// Indicates if the method is deprecated.
    pub is_deprecated: bool,
    /// The generic signature.
    pub signature: Option<MethodSignature>,
    /// Unrecognized JVM attributes.
    pub free_attributes: Vec<(String, Vec<u8>)>,
}

impl Method {
    /// The method of a static initializer block.
    pub const CLASS_INITIALIZER_NAME: &'static str = "<clinit>";
    /// The method of a constructor.
    pub const CONSTRUCTOR_NAME: &'static str = "<init>";

    /// Checks if the method is a constructor.
    #[must_use]
    pub fn is_constructor(&self) -> bool {
        self.name == Self::CONSTRUCTOR_NAME
    }

    /// Checks if the method is a static initializer block.
    #[must_use]
    pub fn is_static_initializer_block(&self) -> bool {
        self.name == Self::CLASS_INITIALIZER_NAME
    }

    /// Creates a [`MethodReference`] pointting to this method.
    #[must_use]
    pub fn make_refernece(&self) -> MethodReference {
        MethodReference {
            owner: self.owner.clone(),
            name: self.name.clone(),
            descriptor: self.descriptor.clone(),
        }
    }
}

/// The information of a method parameter.
#[derive(Debug, Clone)]
pub struct ParameterInfo {
    /// The name of the parameter.
    pub name: Option<String>,
    /// The access flags of the parameter.
    pub access_flags: MethodParameterAccessFlags,
}

bitflags! {
    /// Access flags for a [`Method`].
    #[derive(Debug, PartialEq, Eq, Clone, Copy)]
    pub struct MethodAccessFlags: u16 {
        /// Declared `public`; may be accessed from outside its package.
        const PUBLIC = 0x0001;
        /// Declared `private`; accessible only within the defining class and other classes belonging to the same nest.
        const PRIVATE = 0x0002;
        /// Declared `protected`; may be accessed within subclasses.
        const PROTECTED = 0x0004;
        /// Declared `static`.
        const STATIC = 0x0008;
        /// Declared `final`; must not be overridden.
        const FINAL = 0x0010;
        /// Declared `synchronized`; invocation is wrapped by a monitor use.
        const SYNCHRONIZED = 0x0020;
        /// A bridge method, generated by the compiler.
        const BRIDGE = 0x0040;
        /// Declared with variable number of arguments.
        const VARARGS = 0x0080;
        /// Declared `native`; implemented in a language other than Java.
        const NATIVE = 0x0100;
        /// Declared `abstract`; no implementation is provided.
        const ABSTRACT = 0x0400;
        /// In a `class` file whose major version is at least 46 and at most 60; Declared `strictfp`.
        const STRICT = 0x0800;
        /// Declared synthetic; not present in the source code.
        const SYNTHETIC = 0x1000;
    }
}

bitflags! {
    /// The access flags for a method parameter.
    #[derive(Debug, PartialEq, Eq, Clone, Copy)]
    pub struct MethodParameterAccessFlags: u16 {
        /// Declared `final`; may not be assigned to after initialization.
        const FINAL = 0x0010;
        /// Declared synthetic; not present in the source code.
        const SYNTHETIC = 0x1000;
        /// Declared as either `mandated` or `optional`.
        const MANDATED = 0x8000;
    }
}

/// A reference to a method.
#[derive(Debug, PartialEq, Eq, Hash, Clone)]
pub struct MethodReference {
    /// The reference to the class containing the method.
    pub owner: ClassReference,
    /// The name of the method.
    pub name: String,
    /// The descriptor of the method.
    pub descriptor: MethodDescriptor,
}

impl MethodReference {
    /// Checks if the method reference refers to a constructor.
    #[must_use]
    pub fn is_constructor(&self) -> bool {
        self.name == Method::CONSTRUCTOR_NAME
            && matches!(self.descriptor.return_type, ReturnType::Void)
    }

    /// Checks if the method reference refers to a static initializer block.
    #[must_use]
    pub fn is_static_initializer_block(&self) -> bool {
        self.name == Method::CLASS_INITIALIZER_NAME
            && self.descriptor.parameters_types.is_empty()
            && matches!(self.descriptor.return_type, ReturnType::Void)
    }
}

impl Display for MethodReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}::{}", self.owner, self.name)
    }
}

#[cfg(test)]
mod tests {
    use crate::tests::arb_class_name;

    use super::*;
    use proptest::prelude::*;

    proptest! {

        #[test]
        fn test_is_constructor(class_name in arb_class_name()) {
            let method = MethodReference {
                owner: ClassReference::new(class_name),
                name: Method::CONSTRUCTOR_NAME.to_string(),
                descriptor: "()V".parse().unwrap(),
            };

            assert!(method.is_constructor());
        }

        #[test]
        fn test_is_static_initializer_bolck(class_name in arb_class_name()) {
            let method = MethodReference {
                owner: ClassReference::new(class_name),
                name: Method::CLASS_INITIALIZER_NAME.to_string(),
                descriptor: "()V".parse().unwrap(),
            };

            assert!(method.is_static_initializer_block());
        }
    }
}
