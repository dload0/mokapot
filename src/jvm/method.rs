//! JVM methods.

use bitflags::bitflags;

use crate::{
    macros::see_jvm_spec,
    types::{method_descriptor::MethodDescriptor, signitures::MethodSignature},
};

use super::{
    annotation::{Annotation, ElementValue, Type},
    code::MethodBody,
    references::{ClassRef, MethodRef},
};

/// A JVM method.
#[doc = see_jvm_spec!(4, 6)]
#[derive(Debug, Clone)]
pub struct Method {
    /// The access flags of the method.
    pub access_flags: MethodAccessFlags,
    /// The name of the method.
    pub name: String,
    /// The descriptor of the method.
    pub descriptor: MethodDescriptor,
    /// The class containing the method.
    pub owner: ClassRef,
    /// The body of the method if it is not `abstract`` or `native`.
    pub body: Option<MethodBody>,
    /// The checked exceptions that may be thrown by the method.
    pub exceptions: Vec<ClassRef>,
    /// The runtime visible annotations.
    pub runtime_visible_annotations: Vec<Annotation>,
    /// The runtime invisible annotations.
    pub runtime_invisible_annotations: Vec<Annotation>,
    /// The runtime visible type annotations.
    pub runtime_visible_type_annotations: Vec<Type>,
    /// The runtime invisible type annotations.
    pub runtime_invisible_type_annotations: Vec<Type>,
    /// The runtime visible parameter annotations.
    pub runtime_visible_parameter_annotations: Vec<Vec<Annotation>>,
    /// The runtime invisible parameter annotations.
    pub runtime_invisible_parameter_annotations: Vec<Vec<Annotation>>,
    /// The default value of the annotation.
    pub annotation_default: Option<ElementValue>,
    /// The parameters of the method.
    pub parameters: Vec<ParameterInfo>,
    /// Indicates if the method is synthesized by the compiler.
    pub is_synthetic: bool,
    /// Indicates if the method is deprecated.
    pub is_deprecated: bool,
    /// The generic signature.
    pub signature: Option<MethodSignature>,
    /// Unrecognized JVM attributes.
    pub free_attributes: Vec<(String, Vec<u8>)>,
}

impl Method {
    /// The method of a static initializer block.
    pub const CLASS_INITIALIZER_NAME: &'static str = "<clinit>";
    /// The method of a constructor.
    pub const CONSTRUCTOR_NAME: &'static str = "<init>";

    /// Checks if the method is a constructor.
    #[must_use]
    pub fn is_constructor(&self) -> bool {
        self.name == Self::CONSTRUCTOR_NAME
    }

    /// Checks if the method is a static initializer block.
    #[must_use]
    pub fn is_static_initializer_block(&self) -> bool {
        self.name == Self::CLASS_INITIALIZER_NAME
    }

    /// Creates a [`MethodRef`] pointting to this method.
    #[must_use]
    pub fn as_ref(&self) -> MethodRef {
        MethodRef {
            owner: self.owner.clone(),
            name: self.name.clone(),
            descriptor: self.descriptor.clone(),
        }
    }
}

/// The information of a method parameter.
#[derive(Debug, Clone)]
pub struct ParameterInfo {
    /// The name of the parameter.
    pub name: Option<String>,
    /// The access flags of the parameter.
    pub access_flags: MethodParameterAccessFlags,
}

bitflags! {
    /// Access flags for a [`Method`].
    #[derive(Debug, PartialEq, Eq, Clone, Copy)]
    pub struct MethodAccessFlags: u16 {
        /// Declared `public`; may be accessed from outside its package.
        const PUBLIC = 0x0001;
        /// Declared `private`; accessible only within the defining class and other classes belonging to the same nest.
        const PRIVATE = 0x0002;
        /// Declared `protected`; may be accessed within subclasses.
        const PROTECTED = 0x0004;
        /// Declared `static`.
        const STATIC = 0x0008;
        /// Declared `final`; must not be overridden.
        const FINAL = 0x0010;
        /// Declared `synchronized`; invocation is wrapped by a monitor use.
        const SYNCHRONIZED = 0x0020;
        /// A bridge method, generated by the compiler.
        const BRIDGE = 0x0040;
        /// Declared with variable number of arguments.
        const VARARGS = 0x0080;
        /// Declared `native`; implemented in a language other than Java.
        const NATIVE = 0x0100;
        /// Declared `abstract`; no implementation is provided.
        const ABSTRACT = 0x0400;
        /// In a `class` file whose major version is at least 46 and at most 60; Declared `strictfp`.
        const STRICT = 0x0800;
        /// Declared synthetic; not present in the source code.
        const SYNTHETIC = 0x1000;
    }
}

bitflags! {
    /// The access flags for a method parameter.
    #[derive(Debug, PartialEq, Eq, Clone, Copy)]
    pub struct MethodParameterAccessFlags: u16 {
        /// Declared `final`; may not be assigned to after initialization.
        const FINAL = 0x0010;
        /// Declared synthetic; not present in the source code.
        const SYNTHETIC = 0x1000;
        /// Declared as either `mandated` or `optional`.
        const MANDATED = 0x8000;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    fn arb_access_flag() -> impl Strategy<Value = MethodAccessFlags> {
        prop_oneof![
            Just(MethodAccessFlags::PUBLIC),
            Just(MethodAccessFlags::PRIVATE),
            Just(MethodAccessFlags::PROTECTED),
            Just(MethodAccessFlags::STATIC),
            Just(MethodAccessFlags::FINAL),
            Just(MethodAccessFlags::SYNCHRONIZED),
            Just(MethodAccessFlags::BRIDGE),
            Just(MethodAccessFlags::VARARGS),
            Just(MethodAccessFlags::NATIVE),
            Just(MethodAccessFlags::ABSTRACT),
            Just(MethodAccessFlags::STRICT),
            Just(MethodAccessFlags::SYNTHETIC)
        ]
    }

    fn arb_parameter_access_flag() -> impl Strategy<Value = MethodParameterAccessFlags> {
        prop_oneof![
            Just(MethodParameterAccessFlags::FINAL),
            Just(MethodParameterAccessFlags::SYNTHETIC),
            Just(MethodParameterAccessFlags::MANDATED)
        ]
    }

    proptest! {

        #[test]
        fn access_flags_bit_no_overlap(
            lhs in arb_access_flag(),
            rhs in arb_access_flag()
        ){
            prop_assume!(lhs != rhs);
            assert_eq!(lhs.bits() & rhs.bits(), 0);
        }

        #[test]
        fn parameter_access_flags_bit_no_overlap(
            lhs in arb_parameter_access_flag(),
            rhs in arb_parameter_access_flag()
        ){
            prop_assume!(lhs != rhs);
            assert_eq!(lhs.bits() & rhs.bits(), 0);
        }
    }
}
